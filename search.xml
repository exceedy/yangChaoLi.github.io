<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot 踩坑记 之 日期转化器 （二）]]></title>
    <url>%2FSpringBoot%2FDateConverter%2FSpringBoot%20%E8%B8%A9%E5%9D%91%E8%AE%B0%20%E4%B9%8B%20%E6%97%A5%E6%9C%9F%E8%BD%AC%E5%8C%96%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[啊，依旧骚气的前言 咳咳，接长达一天间隔的上一篇，终于在我不懈的努力下，可以在使用RequestBody时不加注解的办法，被公司大佬完成了，嗯，完美。 全局配置（哎呀，怎么能有这么正经的标题） 大部分代码其实和上一篇相同，只不过是在全局配置的时候需要对ObjectMapper进行部分值的修改，大体意思就是修改Jackson的对象映射，听起来是不是很简（懵）单（逼）。懵就对了，我也很懵。 首先需要继承SimpleDateFormat，然后重写里面的方法，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.springframework.core.convert.converter.Converter;import java.text.*;import java.util.Date;public class DefaultDateFormat extends SimpleDateFormat &#123; private static DateFormat FORMAT_DATE_TIME = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); private static DateFormat FORMAT_DATE = new SimpleDateFormat("yyyy-MM-dd"); public Date convert(String source) &#123; if (source == null) &#123; return null; &#125; // 如果都是数字则是long if (source.matches("\\d+")) &#123; return new Date(Long.parseLong(source)); &#125; // 如果是yyyy-MM-dd格式 if (source.matches("^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125; \\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;$")) &#123; Date date = null; try &#123; date = FORMAT_DATE.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; // 如果是yyyy-MM-dd HH:mm:ss if (source.matches("^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125; \\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;$")) &#123; Date date = null; try &#123; date = FORMAT_DATE_TIME.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; return null; &#125; @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) &#123; return FORMAT_DATE_TIME.format(date, toAppendTo, fieldPosition); &#125; @Override public Date parse(String source) &#123; Date convert = convert(source); return convert; &#125; @Override public Date parse(String source, ParsePosition pos) &#123; Date convert = convert(source); return convert; &#125; 然后在上篇博客提到的继承WebMvcConfigurationSupport的WebMvcCloudConfigure类中，重写extendMessageConverters()方法，就可以了： 1234567891011121314151617@Override protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; for (HttpMessageConverter httpMessageConverter : converters) &#123; if (httpMessageConverter instanceof MappingJackson2HttpMessageConverter) &#123; MappingJackson2HttpMessageConverter conver = (MappingJackson2HttpMessageConverter) httpMessageConverter; ObjectMapper objectMapper = new ObjectMapper(); // 统一返回数据的输出风格 objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); objectMapper.setTimeZone(TimeZone.getTimeZone("UTC")); objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); objectMapper.setDateFormat(new DefaultDateFormat()); conver.setObjectMapper(objectMapper); break; &#125; &#125; &#125; 在这里提一下，如果你觉得写两个类很麻烦，那么细心的你有没有发现上一篇的DateConverter类和这篇中的DefaultDateFormat类中有相似的地方呢，没错，这个类了面也写了convert()这个方法，虽然是自己写的，但是没关系，我们实现一下Converter接口，然后convert方法就变成重写啦，之后WebMvcCloudConfigure的addFormatters()方法稍作修改，两个类就可以合二为一，就可以只用这篇中的类啦，是不是有剩了好大的代码量呢。 当然你也可以根据需要，依旧采用上篇的方式。改动如下： DefaultDateFormat类改动： 12345678public class DefaultDateFormat extends SimpleDateFormat implements Converter&lt;String, Date&gt; &#123; ... @Override public Date convert(String source) &#123; ... &#125; ...&#125; WebMvcCloudConfigure类改动： 1234 @Overrideprotected void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new DefaultDateFormat());&#125; 好的， 历经三天的远征，终于把坑填好了，哎，效率果然低了。没办法慢慢学吧，加油！漫漫长夜，又水完一篇博客，舒服。]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>DateConverter</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 踩坑记 之 日期转化器 （一）]]></title>
    <url>%2FSpringBoot%2FDateConverter%2FSpringBoot%20%E8%B8%A9%E5%9D%91%E8%AE%B0%20%E4%B9%8B%20%E6%97%A5%E6%9C%9F%E8%BD%AC%E5%8C%96%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[骚气的前言SpringBoot @RequestBody 在写接口的时候用这个注解接收对象，哇塞，简直好用的一批，@RequestBody 转换对象时使用的是Jackson。 jackson千好万好，但是居然不支持”yyyy-MM-dd HH:mm:ss”这个格式，大佬，您都支持”yyyy-MM-dd HH:mm:ss.SSSZ”这个格式了，为嘛不支持一下CN常用的格式嘞。咳咳，吐槽的话不多说，毕竟人家是大佬。那么接下来就是为RequestBody做一个自定义的日期转换器了。 现在博主使用的方式是进行局部转换，还没找到不加注解就转换的好方法，找到后后期会更新。好了废话有点多，接下来就上代码： 顺带一提，使用@JsonFormat(pattern=”yyyy-MM-dd HH:mm:ss”, timezone=”GMT+8”)这个方式也不可行，只要是用@RequestBody，好像就和这个格式绝缘一样，当然也有可能是博主使用有问题，有问题的话欢迎指出。 正儿八经的局部转换方法 博主目前使用的是@JsonDeserialize和@JsonSerialize。首先需要一个类来继承JsonDeserializer,然后重写里面的deserialize方法： 123456789101112131415161718192021222324252627282930313233343536373839 import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.DeserializationContext;import com.fasterxml.jackson.databind.JsonDeserializer;import org.springframework.stereotype.Component;import java.io.IOException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * @author Mr.Y * @time 2019/3/7/16:28 * @note 在接口接受对象使用@RequestBody时,在对象中Date类型的变量上添加注解@JsonDeserialize(using = DateJsonDeserializer.class) */@Componentpublic class DateJsonDeserializer extends JsonDeserializer&lt;Date&gt; &#123; private static SimpleDateFormat simpleDateFormat = null; @Override public Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException &#123; String time = jsonParser.getText(); time = time.trim(); if (time.contains(" ")) &#123; simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); &#125; else &#123; simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd"); &#125; try &#123; return simpleDateFormat.parse(time); &#125; catch (ParseException e) &#123; // 可能是时间戳 Long _time = Long.valueOf(String.valueOf(jsonParser.getText())); return new Date(_time); &#125; &#125;&#125; 接下来就是在对象中添加注解，方式很简单： 12@JsonDeserialize(using = DateJsonDeserializer.class)private Date date; 好，至此大工当然没有告成。 差点忘记的全局配置方法上述的代码只是对@RequestBody进行了处理，让Date的转换可以按照我们自定义的方式进行。接下来就是让不使用RequestBody的接口接受参数时进行时间的转换了。 全局配置的处理方式是实现Converter接口，重写convert方法，然后进行全局配置。代码在这：12345678910111213141516171819202122232425262728293031323334import org.springframework.core.convert.converter.Converter;import org.springframework.stereotype.Component;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * @author Mr.Y * @time 2019/3/6/16:53 */@Componentpublic class DateConverter implements Converter&lt;String, Date&gt; &#123; SimpleDateFormat simpleDateFormat = null; @Override public Date convert(String o) &#123; String time = (String) o; time = time.trim(); if (time.contains(" ")) &#123; simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); &#125; else &#123; simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd"); &#125; try &#123; return simpleDateFormat.parse(time); &#125; catch (ParseException e) &#123; // 可能是时间戳 Long _time = Long.valueOf(String.valueOf(o)); return new Date(_time); &#125; &#125;&#125; 然后进行全局配置，全局配置需要继承WebMvcConfigurationSupport类，然后重写addFormatters方法，代码如下：1234567@Configurationpublic class WebMvcCloudConfigure extends WebMvcConfigurationSupport &#123; @Override protected void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new DateConverter()); &#125;&#125; 好的，到这里才是大功告成，是不是很简(炸)单(裂)。哎，一把心酸类，踩了两天的坑，终于有点样子了。继续学习，加油！]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>DateConverter</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux sendEmail 踩坑记 （一）]]></title>
    <url>%2Flinux%2FsendEmail%2Flinux%20sendEmail%20%E8%B8%A9%E5%9D%91%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[linux 可以直接发送email，需要借助sendEmail工具，废话少说直接上代码1234567891011121314151617# 下载安装包wget http://caspian.dotconf.net/menu/Software/SendEmail/sendEmail-v1.56.tar.gz# 解压tar zxf sendEmail-v1.56.tar.gz# 进入解压目录cd /usr/src/sendEmail-v1.56/#复制程序到指定目录cp -a sendEmail /usr/local/bin/#给执行权限chmod +x /usr/local/bin/sendEmail#安装组件yum install perl-Net-SSLeay perl-IO-Socket-SSL -y sendEmail 参数1234567891011sendEmail -h-f 表示发送者的邮箱-t 表示接收者的邮箱-s 表示SMTP服务器的域名或者ip-u 表示邮件的主题-xu 表示SMTP验证的用户名-xp 表示SMTP验证的密码(注意,这个密码貌似有限制,例如我用d!5neyland就不能被正确识别)-m 表示邮件的内容-cc 表示抄送-bcc 表示暗抄送 发送邮件测试12#发送邮件/usr/local/bin/sendEmail -f hhh@163.com -t 123456789@qq.com -s smtp.163.com -u &quot;测试&quot;-xu hhh@163.com -xp @453163.com -m &quot;test-1234567890&quot; 发送邮箱测试时会报如下错误，原因是perl版本不兼容 12345678910 ******************************************************************* Using the default of SSL_verify_mode of SSL_VERIFY_NONE for client is deprecated! Please set SSL_verify_mode to SSL_VERIFY_PEER possibly with SSL_ca_file|SSL_ca_path for verification. If you really don&apos;t want to verify the certificate and keep the connection open to Man-In-The-Middle attacks please set SSL_verify_mode explicitly to SSL_VERIFY_NONE in your application.******************************************************************* at /usr/local/bin/sendEmail line 1906.invalid SSL_version specified at /usr/share/perl5/vendor_perl/IO/Socket/SSL.pm line 444. 解决方案，sendEmail 增加两个参数1-o tls=no // sendEmail -h 查看帮助，解释是 -o tls=&lt;auto|yes|no&gt; -o fqdn=FQDN 即不验证 ssl 完整的正确命令是：1/usr/local/bin/sendEmail -f hhh@163.com -t 123456789@qq.com -s smtp.163.com -u &quot;测试&quot;-xu hhh@163.com -xp @453163.com -m &quot;正文&quot; -o tls = no 上述问题还有解决perl版本冲突的方案，博主还没测试，等测试可用后再进行更新。执行发送命令时需要注意 -xp 的密码并不是发送邮箱的本身密码，以163邮箱为例，需要开启smtp等权限，然后生成授权码，该密码为生成的授权码。设置授权码详情整理后更新 参考网址：http://www.mamicode.com/info-detail-2404622.html参考网址：https://blog.csdn.net/ithomer/article/details/83514232]]></content>
      <categories>
        <category>linux</category>
        <category>sendEmail</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[1我的天呢，终于弄好了，纪念一下]]></content>
  </entry>
</search>

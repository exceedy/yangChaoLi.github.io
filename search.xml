<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql 踩坑记 （一）]]></title>
    <url>%2Fsql%2Fmysql%E8%B8%A9%E5%9D%91%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天某贱贱的同事，给我出了个题,关于sql查询的题，那么直接开始吧。 题目： id userid start end 1 2 18 28 2 2 34 44 3 2 24 44 获得从开始时间(start)到结束时间(end)的总时长,重复时间按一个时间算。 代码解答:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364delimiter //CREATE PROCEDURE test() BEGINDECLARE oneStart INT;DECLARE oneEnd INT;DECLARE twoStart INT;DECLARE twoEnd INT;DECLARE count INT default 0;-- DECLARE-- start_ INT;-- DECLARE-- end_ INT;declare done int default false;DECLARE my_test CURSOR FOR ( SELECT START, END FROM ruizhi WHERE userid = 2 ORDER BY START ASC );declare continue HANDLER for not found set done = true; OPEN my_test;FETCH my_test INTO oneStart,oneEnd;read_loop:loop FETCH my_test INTO twoStart,twoEnd; if done then leave read_loop; # 跳出游标循环 end if; SELECT twoStart,twoEnd; IF twoStart &lt; oneStart THEN SET oneStart = twoStart; END IF; -- 如果第一行的结束小于第二行的开始就记录第一行的结果。并更新start为第二行。 IF oneEnd &lt; twoStart THEN SET count = count + ( oneEnd - oneStart ); SET oneStart = twoStart; SET oneEnd = twoEnd; ELSEIF twoEnd &gt; oneEnd THEN-- 第二行开始时间包含在第一行，那么对比结束时间 SET oneEnd = twoEnd; END IF ;-- SELECT start_,end_,count;end loop;SET count = count + ( oneEnd - oneStart ); CLOSE my_test ;SELECT count;END // delimiter ;call test();oEnd &gt; oneEnd THEN-- 第二行开始时间包含在第一行，那么对比结束时间 SET oneEnd = twoEnd; END IF ;-- SELECT start_,end_,count;end loop;SET count = count + ( oneEnd - oneStart ); CLOSE my_test ;SELECT count;END // delimiter ;call test(); 代码解析 声明：declare declare data data_type。声明变量，declare使用时需要注意放在BEGIN …END 之间，并且是所有其他语句之前。 浮标：cursor 创建浮标： declare cur cursor for select * from test; 打开浮标 open cur； 获取浮标当前位置的值并赋值给变量，浮标位置前进一位 fetch cur into data； 开启浮标循环 read_loop:loop; 退出浮标循环 leave read_loop; 浮标循环实例 123456789101112 declare done int default false; --设置浮标控制变量 DECLARE my_test CURSOR FOR ( SELECT START, END FROM ruizhi WHERE userid = 2 ORDER BY START ASC );--创建浮标 declare continue HANDLER for not found set done = true; --浮标查询结束后返回。 open my_test; --打开浮标 read_loop:loop;--开启浮标循环 fetch my_test into data;--获取浮标当前位置内容并前进一。 if done then leave read_loop;--退出loop循环 end if；end loop；--使用loop，必须要关闭。close my_test;--关闭浮标 while 循环 123while boolean do 业务end while; if 语句 12345if boolean then 业务，这里要注意写法和java相同，每行都要以";"结尾else业务 同上end if； 存储过程 CREATE PROCEDURE test() begin end; 开始要进行结束符转化 delimiter // – 设置结尾符为”//“]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>msyql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker 踩坑记 （一）]]></title>
    <url>%2Flinux%2Fdocker%2Fdocker%E8%B8%A9%E5%9D%91%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[直奔主题吧，介绍文会新建一个，这里直接就开始安装使用吧 CentOS 7 安装docker CentOS 可以直接使用命令行安装： 1$ sudo yum install docker 测试Docker版本 1.运行 --version``` 可以查看docker版本1 $ docker –version Docker version 1.13.1, build b2f74b2/1.13.1 12.运行 ```docker info``` 查看docker安装的更多详细信息 $ docker info Containers: 7 Running: 0 Paused: 0 Stopped: 7 Images: 3 Server Version: 1.13.1 Storage Driver: overlay2 Backing Filesystem: xfs Supports d_type: true Native Overlay Diff: true Logging Driver: journald Cgroup Driver: systemd .... 123#### 测试Docker安装1. 通过运行简单的Docker镜像hello-world来测试安装是否有效 $ docker run hello-world Unable to find image &apos;hello-world:latest&apos; locally latest: Pulling from library/hello-world ca4f61b1923c: Pull complete Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. ... 122. 列出hello-world 下载到虚拟机的镜像 docker image ls 13. 列出 hello-world 在显示其消息后退出的容器，如果它仍在运行，将不需要 --all选项； docker container ls –all CONTAINER ID IMAGE COMMAND CREATED STATUS 54f4984ed6a8 hello-world “/hello” 20 seconds ago Exited (0) 19 seconds ago `]]></content>
      <categories>
        <category>linux</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 踩坑记 之 集成webSocket （二）]]></title>
    <url>%2FSpringBoot%2FwebSocket%2FSpringBoot%20%E8%B8%A9%E5%9D%91%E8%AE%B0%20%E4%B9%8B%20%20%E9%9B%86%E6%88%90webSocket%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基于stomp版的，啊，有个demo，但是还没实际用过，不想写怎么办，在线等，一点也不急那种。]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>webSocket</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 踩坑记 之 集成webSocket （一）]]></title>
    <url>%2FSpringBoot%2FwebSocket%2FSpringBoot%20%E8%B8%A9%E5%9D%91%E8%AE%B0%20%E4%B9%8B%20%20%E9%9B%86%E6%88%90webSocket%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 springboot 集成webSocket是很方便简单的，当然对于博主这种小萌新还是需要多努力的，经过不断的度娘终于完成了可用的demo，虽然都是搬的，但是还是要做做笔记。 好的，为了能加深印象，简单说一下webSocket的用处，webSocket是单个TCP链接提供全双工（双向通信）通信的计算机通信协议。webSocket允许服务端主动向客户端推送数据，在浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的链接，并进行双向数据传输。 接下来就是代码时刻： 首先springboot集成websocket在pom文件内直接加入以下代码 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt; 1. 先从配置开始主要配置文件，配置了链接webSocket的访问路径 123456789101112131415161718192021222324252627282930313233343536373839404142import cn.tdchain.cloud.interceptor.SocketInterceptor;import cn.tdchain.cloud.service.websocket.MyWebSocketHandler;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.config.annotation.EnableWebSocket;import org.springframework.web.socket.config.annotation.WebSocketConfigurer;import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;/*** @author Mr.Y* @time 2019/3/12/11:33*/@Configuration@EnableWebSocketpublic class WebSocketConfig implements WebSocketConfigurer &#123; @Autowired private SocketInterceptor handshake; @Autowired private MyWebSocketHandler handler; /** * 实现 WebSocketConfigurer 接口，重写 registerWebSocketHandlers 方法，这是一个核心实现方法，配置 websocket 入口，允许访问的域、注册 Handler、SockJs 支持和拦截器。 * &lt;p&gt; * registry.addHandler()注册和路由的功能，当客户端发起 websocket 连接，把 /path 交给对应的 handler 处理，而不实现具体的业务逻辑，可以理解为收集和任务分发中心。 * &lt;p&gt; * addInterceptors，顾名思义就是为 handler 添加拦截器，可以在调用 handler 前后加入我们自己的逻辑代码。 * &lt;p&gt; * setAllowedOrigins(String[] domains),允许指定的域名或 IP (含端口号)建立长连接，如果只允许自家域名访问，这里轻松设置。如果不限时使用”*”号，如果指定了域名，则必须要以 http 或 https 开头。 * * @param registry */ @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123; //部分 支持websocket 的访问链接,允许跨域 registry.addHandler(handler, "/echo").addInterceptors(handshake).setAllowedOrigins("*"); //部分 不支持websocket的访问链接,允许跨域 registry.addHandler(handler, "/sockjs/echo").addInterceptors(handshake).setAllowedOrigins("*").withSockJS(); &#125;&#125; 2. 实现HandshakeInterceptor拦截器，在客户端与服务端握手前后进行操作123456789101112131415161718192021222324252627282930313233343536import cn.tdchain.cloud.constant.WebSocketUrlType;import org.springframework.http.server.ServerHttpRequest;import org.springframework.http.server.ServerHttpResponse;import org.springframework.http.server.ServletServerHttpRequest;import org.springframework.stereotype.Service;import org.springframework.web.socket.WebSocketHandler;import org.springframework.web.socket.server.HandshakeInterceptor;import javax.servlet.http.HttpServletRequest;import java.util.Map;/** * @author Mr.Y * @time 2019/3/12/10:03 */@Servicepublic class SocketInterceptor implements HandshakeInterceptor &#123; @Override public boolean beforeHandshake(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler webSocketHandler, Map&lt;String, Object&gt; map) throws Exception &#123; if (serverHttpRequest instanceof ServletServerHttpRequest) &#123; HttpServletRequest request = ((ServletServerHttpRequest)serverHttpRequest).getServletRequest(); String user = (String) request.getAttribute(WebSocketUrlType.WEBSOCKET_USERNAME); if (user == null) &#123; user = (String) request.getSession().getAttribute(WebSocketUrlType.WEBSOCKET_USERNAME); &#125; System.out.println("-------socket" +user); map.put(WebSocketUrlType.WEBSOCKET_USERNAME,user); &#125; return true; &#125; @Override public void afterHandshake(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler webSocketHandler, Exception e) &#123; &#125;&#125; 3、实现WebSocketHandler,该功能主要用于消息分发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import cn.tdchain.cloud.constant.WebSocketUrlType;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;import org.springframework.web.socket.*;import java.io.IOException;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;/** * @author Mr.Y * @time 2019/3/12/9:51 */@Servicepublic class MyWebSocketHandler implements WebSocketHandler &#123; Logger logger = LoggerFactory.getLogger(MyWebSocketHandler.class); private final static List&lt;WebSocketSession&gt; webSocketSessions = Collections.synchronizedList(new ArrayList&lt;WebSocketSession&gt;()); @Override public void afterConnectionEstablished(WebSocketSession webSocketSession) throws Exception &#123; logger.info(&quot;webSocket 链接成功&quot;); webSocketSessions.add(webSocketSession); String userName = (String) webSocketSession.getAttributes().get(WebSocketUrlType.WEBSOCKET_USERNAME); System.out.println(&quot;--------user:&quot; + userName); if (userName != null) &#123; JSONObject obj = new JSONObject(); // 统计当前链接人数 obj.put(&quot;count&quot;, webSocketSessions.size()); users(obj); webSocketSession.sendMessage(new TextMessage(obj.toJSONString())); &#125; &#125; @Override public void handleMessage(WebSocketSession webSocketSession, WebSocketMessage&lt;?&gt; webSocketMessage) throws Exception &#123; logger.info(&quot;处理消息发送&quot;); JSONObject msg = JSON.parseObject(webSocketMessage.getPayload().toString()); JSONObject obj = new JSONObject(); if (msg.getInteger(&quot;type&quot;) == 1) &#123; // 发送给所有人 obj.put(&quot;msg&quot;, msg.getString(&quot;msg&quot;)); sendMessageToUser(new TextMessage(obj.toJSONString())); &#125; else &#123; String to = msg.getString(&quot;to&quot;); obj.put(&quot;msg&quot;, msg.getString(&quot;msg&quot;)); sendMessageToUser(to, new TextMessage(obj.toJSONString())); &#125; &#125; @Override public void handleTransportError(WebSocketSession webSocketSession, Throwable throwable) throws Exception &#123; if (webSocketSession.isOpen()) &#123; webSocketSession.close(); &#125; logger.info(&quot;链接出错，断开链接。。。&quot;); webSocketSessions.remove(webSocketSession); &#125; @Override public void afterConnectionClosed(WebSocketSession webSocketSession, CloseStatus closeStatus) throws Exception &#123; logger.info(&quot;链接断开&quot;); webSocketSessions.remove(webSocketSession); &#125; @Override public boolean supportsPartialMessages() &#123; return false; &#125; /** * 给所有用户发消息 * * @param message */ public static void sendMessageToUser(TextMessage message) &#123; webSocketSessions.forEach(v -&gt; &#123; if (v.isOpen()) &#123; try &#123; v.sendMessage(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; /** * 发送给指定用户 * * @param to * @param message */ public static void sendMessageToUser(String to, TextMessage message) &#123; webSocketSessions.forEach(v -&gt; &#123; if (v.getAttributes().get(WebSocketUrlType.WEBSOCKET_USERNAME).equals(to)) &#123; if (v.isOpen()) &#123; try &#123; v.sendMessage(message); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;); &#125; /** * 将所有用户发送到前端 * * @param obj */ private void users(JSONObject obj) &#123; List&lt;String&gt; userNames = new ArrayList&lt;&gt;(); webSocketSessions.forEach(v -&gt; &#123; userNames.add((String) v.getAttributes().get(WebSocketUrlType.WEBSOCKET_USERNAME)); &#125;); obj.put(&quot;users&quot;, userNames); &#125; public static List&lt;WebSocketSession&gt; getWebSocketSessions() &#123; return webSocketSessions; &#125;&#125; 使用方式前端js代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354$(function () &#123; var websocket; if ('WebSocket' in window) &#123; console.log("WebSocket"); websocket = new WebSocket("ws://localhost:8080/cloud/echo"); &#125; else if ('MozWebSocket' in window) &#123; console.log("MozWebSocket"); websocket = new MozWebSocket("ws://cloud/echo"); &#125; else &#123; console.log("SockJS"); websocket = new SockJS("http://127.0.0.1:8080/cloud/sockjs/echo"); &#125; websocket.onopen = function (evnt) &#123; console.log("链接服务器成功!", evnt.data); &#125;; websocket.onmessage = function (evnt) &#123; console.log('收到消息:', evnt.data); var json = JSON.parse(evnt.data); if (json.hasOwnProperty('users')) &#123; var users = json.users; for (var i = 0; i &lt; users.length; i++) &#123; $("#inputGroupSelect01").append('&lt;option value="' + users[i] + '"&gt;' + users[i] + '&lt;/option&gt;'); &#125; &#125; else &#123; //打印消息 toast(json, 'info') &#125; &#125;; websocket.onerror = function (evnt) &#123; &#125;; websocket.onclose = function (evnt) &#123; console.log("与服务器断开了链接!") &#125; &#125;); function toast(text, icon) &#123; $.toast(&#123; text: text, heading: '新消息', icon: icon, showHideTransition: 'slide', allowToastClose: true, hideAfter: 3000, stack: 5, position: 'top-right', bgColor: '#444444', textColor: '#eeeeee', textAlign: 'left', loader: true, loaderBg: '#006eff' &#125;); &#125;]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>webSocket</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 踩坑记 之 日期转化器 （二）]]></title>
    <url>%2FSpringBoot%2FDateConverter%2FSpringBoot%20%E8%B8%A9%E5%9D%91%E8%AE%B0%20%E4%B9%8B%20%E6%97%A5%E6%9C%9F%E8%BD%AC%E5%8C%96%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[啊，依旧骚气的前言 咳咳，接长达一天间隔的上一篇，终于在我不懈的努力下，可以在使用RequestBody时不加注解的办法，被公司大佬完成了，嗯，完美。 全局配置（哎呀，怎么能有这么正经的标题） 大部分代码其实和上一篇相同，只不过是在全局配置的时候需要对ObjectMapper进行部分值的修改，大体意思就是修改Jackson的对象映射，听起来是不是很简（懵）单（逼）。懵就对了，我也很懵。 首先需要继承SimpleDateFormat，然后重写里面的方法，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.springframework.core.convert.converter.Converter;import java.text.*;import java.util.Date;public class DefaultDateFormat extends SimpleDateFormat &#123; private static DateFormat FORMAT_DATE_TIME = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); private static DateFormat FORMAT_DATE = new SimpleDateFormat("yyyy-MM-dd"); public Date convert(String source) &#123; if (source == null) &#123; return null; &#125; // 如果都是数字则是long if (source.matches("\\d+")) &#123; return new Date(Long.parseLong(source)); &#125; // 如果是yyyy-MM-dd格式 if (source.matches("^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125; \\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;$")) &#123; Date date = null; try &#123; date = FORMAT_DATE.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; // 如果是yyyy-MM-dd HH:mm:ss if (source.matches("^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125; \\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;$")) &#123; Date date = null; try &#123; date = FORMAT_DATE_TIME.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; return null; &#125; @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) &#123; return FORMAT_DATE_TIME.format(date, toAppendTo, fieldPosition); &#125; @Override public Date parse(String source) &#123; Date convert = convert(source); return convert; &#125; @Override public Date parse(String source, ParsePosition pos) &#123; Date convert = convert(source); return convert; &#125; 然后在上篇博客提到的继承WebMvcConfigurationSupport的WebMvcCloudConfigure类中，重写extendMessageConverters()方法，就可以了： 1234567891011121314151617@Override protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; for (HttpMessageConverter httpMessageConverter : converters) &#123; if (httpMessageConverter instanceof MappingJackson2HttpMessageConverter) &#123; MappingJackson2HttpMessageConverter conver = (MappingJackson2HttpMessageConverter) httpMessageConverter; ObjectMapper objectMapper = new ObjectMapper(); // 统一返回数据的输出风格 objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); objectMapper.setTimeZone(TimeZone.getTimeZone("UTC")); objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); objectMapper.setDateFormat(new DefaultDateFormat()); conver.setObjectMapper(objectMapper); break; &#125; &#125; &#125; 在这里提一下，如果你觉得写两个类很麻烦，那么细心的你有没有发现上一篇的DateConverter类和这篇中的DefaultDateFormat类中有相似的地方呢，没错，这个类了面也写了convert()这个方法，虽然是自己写的，但是没关系，我们实现一下Converter接口，然后convert方法就变成重写啦，之后WebMvcCloudConfigure的addFormatters()方法稍作修改，两个类就可以合二为一，就可以只用这篇中的类啦，是不是有剩了好大的代码量呢。 当然你也可以根据需要，依旧采用上篇的方式。改动如下： DefaultDateFormat类改动： 12345678public class DefaultDateFormat extends SimpleDateFormat implements Converter&lt;String, Date&gt; &#123; ... @Override public Date convert(String source) &#123; ... &#125; ...&#125; WebMvcCloudConfigure类改动： 1234 @Overrideprotected void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new DefaultDateFormat());&#125; 好的， 历经三天的远征，终于把坑填好了，哎，效率果然低了。没办法慢慢学吧，加油！漫漫长夜，又水完一篇博客，舒服。]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>DateConverter</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 踩坑记 之 日期转化器 （一）]]></title>
    <url>%2FSpringBoot%2FDateConverter%2FSpringBoot%20%E8%B8%A9%E5%9D%91%E8%AE%B0%20%E4%B9%8B%20%E6%97%A5%E6%9C%9F%E8%BD%AC%E5%8C%96%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[骚气的前言SpringBoot @RequestBody 在写接口的时候用这个注解接收对象，哇塞，简直好用的一批，@RequestBody 转换对象时使用的是Jackson。 jackson千好万好，但是居然不支持”yyyy-MM-dd HH:mm:ss”这个格式，大佬，您都支持”yyyy-MM-dd HH:mm:ss.SSSZ”这个格式了，为嘛不支持一下CN常用的格式嘞。咳咳，吐槽的话不多说，毕竟人家是大佬。那么接下来就是为RequestBody做一个自定义的日期转换器了。 现在博主使用的方式是进行局部转换，还没找到不加注解就转换的好方法，找到后后期会更新。好了废话有点多，接下来就上代码： 顺带一提，使用@JsonFormat(pattern=”yyyy-MM-dd HH:mm:ss”, timezone=”GMT+8”)这个方式也不可行，只要是用@RequestBody，好像就和这个格式绝缘一样，当然也有可能是博主使用有问题，有问题的话欢迎指出。 正儿八经的局部转换方法 博主目前使用的是@JsonDeserialize和@JsonSerialize。首先需要一个类来继承JsonDeserializer,然后重写里面的deserialize方法： 123456789101112131415161718192021222324252627282930313233343536373839 import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.DeserializationContext;import com.fasterxml.jackson.databind.JsonDeserializer;import org.springframework.stereotype.Component;import java.io.IOException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * @author Mr.Y * @time 2019/3/7/16:28 * @note 在接口接受对象使用@RequestBody时,在对象中Date类型的变量上添加注解@JsonDeserialize(using = DateJsonDeserializer.class) */@Componentpublic class DateJsonDeserializer extends JsonDeserializer&lt;Date&gt; &#123; private static SimpleDateFormat simpleDateFormat = null; @Override public Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException &#123; String time = jsonParser.getText(); time = time.trim(); if (time.contains(" ")) &#123; simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); &#125; else &#123; simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd"); &#125; try &#123; return simpleDateFormat.parse(time); &#125; catch (ParseException e) &#123; // 可能是时间戳 Long _time = Long.valueOf(String.valueOf(jsonParser.getText())); return new Date(_time); &#125; &#125;&#125; 接下来就是在对象中添加注解，方式很简单： 12@JsonDeserialize(using = DateJsonDeserializer.class)private Date date; 好，至此大工当然没有告成。 差点忘记的全局配置方法上述的代码只是对@RequestBody进行了处理，让Date的转换可以按照我们自定义的方式进行。接下来就是让不使用RequestBody的接口接受参数时进行时间的转换了。 全局配置的处理方式是实现Converter接口，重写convert方法，然后进行全局配置。代码在这：12345678910111213141516171819202122232425262728293031323334import org.springframework.core.convert.converter.Converter;import org.springframework.stereotype.Component;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * @author Mr.Y * @time 2019/3/6/16:53 */@Componentpublic class DateConverter implements Converter&lt;String, Date&gt; &#123; SimpleDateFormat simpleDateFormat = null; @Override public Date convert(String o) &#123; String time = (String) o; time = time.trim(); if (time.contains(" ")) &#123; simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); &#125; else &#123; simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd"); &#125; try &#123; return simpleDateFormat.parse(time); &#125; catch (ParseException e) &#123; // 可能是时间戳 Long _time = Long.valueOf(String.valueOf(o)); return new Date(_time); &#125; &#125;&#125; 然后进行全局配置，全局配置需要继承WebMvcConfigurationSupport类，然后重写addFormatters方法，代码如下：1234567@Configurationpublic class WebMvcCloudConfigure extends WebMvcConfigurationSupport &#123; @Override protected void addFormatters(FormatterRegistry registry) &#123; registry.addConverter(new DateConverter()); &#125;&#125; 好的，到这里才是大功告成，是不是很简(炸)单(裂)。哎，一把心酸类，踩了两天的坑，终于有点样子了。继续学习，加油！]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>DateConverter</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux sendEmail 踩坑记 （一）]]></title>
    <url>%2Flinux%2FsendEmail%2Flinux%20sendEmail%20%E8%B8%A9%E5%9D%91%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[linux 可以直接发送email，需要借助sendEmail工具，废话少说直接上代码1234567891011121314151617# 下载安装包wget http://caspian.dotconf.net/menu/Software/SendEmail/sendEmail-v1.56.tar.gz# 解压tar zxf sendEmail-v1.56.tar.gz# 进入解压目录cd /usr/src/sendEmail-v1.56/#复制程序到指定目录cp -a sendEmail /usr/local/bin/#给执行权限chmod +x /usr/local/bin/sendEmail#安装组件yum install perl-Net-SSLeay perl-IO-Socket-SSL -y sendEmail 参数1234567891011sendEmail -h-f 表示发送者的邮箱-t 表示接收者的邮箱-s 表示SMTP服务器的域名或者ip-u 表示邮件的主题-xu 表示SMTP验证的用户名-xp 表示SMTP验证的密码(注意,这个密码貌似有限制,例如我用d!5neyland就不能被正确识别)-m 表示邮件的内容-cc 表示抄送-bcc 表示暗抄送 发送邮件测试12#发送邮件/usr/local/bin/sendEmail -f hhh@163.com -t 123456789@qq.com -s smtp.163.com -u &quot;测试&quot;-xu hhh@163.com -xp @453163.com -m &quot;test-1234567890&quot; 发送邮箱测试时会报如下错误，原因是perl版本不兼容 12345678910 ******************************************************************* Using the default of SSL_verify_mode of SSL_VERIFY_NONE for client is deprecated! Please set SSL_verify_mode to SSL_VERIFY_PEER possibly with SSL_ca_file|SSL_ca_path for verification. If you really don&apos;t want to verify the certificate and keep the connection open to Man-In-The-Middle attacks please set SSL_verify_mode explicitly to SSL_VERIFY_NONE in your application.******************************************************************* at /usr/local/bin/sendEmail line 1906.invalid SSL_version specified at /usr/share/perl5/vendor_perl/IO/Socket/SSL.pm line 444. 解决方案，sendEmail 增加两个参数1-o tls=no // sendEmail -h 查看帮助，解释是 -o tls=&lt;auto|yes|no&gt; -o fqdn=FQDN 即不验证 ssl 完整的正确命令是：1/usr/local/bin/sendEmail -f hhh@163.com -t 123456789@qq.com -s smtp.163.com -u &quot;测试&quot;-xu hhh@163.com -xp @453163.com -m &quot;正文&quot; -o tls = no 上述问题还有解决perl版本冲突的方案，博主还没测试，等测试可用后再进行更新。执行发送命令时需要注意 -xp 的密码并不是发送邮箱的本身密码，以163邮箱为例，需要开启smtp等权限，然后生成授权码，该密码为生成的授权码。设置授权码详情整理后更新 参考网址：http://www.mamicode.com/info-detail-2404622.html参考网址：https://blog.csdn.net/ithomer/article/details/83514232]]></content>
      <categories>
        <category>linux</category>
        <category>sendEmail</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[1我的天呢，终于弄好了，纪念一下]]></content>
  </entry>
</search>
